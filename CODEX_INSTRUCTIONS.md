# CRITICAL INSTRUCTIONS FOR CODEX - Working Dataverse Pattern

This document contains the EXACT working pattern from GeorgCodeTemplate that successfully connects to Dataverse.

## ğŸš¨ CRITICAL FACTS

### 1. DO NOT Manually Create Services
**NEVER** manually create `dataverseService.ts` files. The official way is:

```bash
pac code add-data-source -a dataverse -t <table-logical-name>
```

This command **auto-generates** 4 files per table:
- `/generated/hooks/useTableName.ts`
- `/generated/models/table-name-model.ts`
- `/generated/services/table-name-service.ts`
- `/generated/validators/table-name-validator.ts`

### 2. Import Paths - CRITICAL DIFFERENCE

**In Vibe apps** (internal Microsoft tool):
```typescript
import { getClient } from '../../../app-gen-sdk/data';
import type { IOperationResult } from '@microsoft/power-apps/data';
```

**In regular Code Apps** (what you're building):
```typescript
import { getClient, type IOperationResult } from '@microsoft/power-apps-data';
```

**âš ï¸ YOU MUST USE THE SECOND PATTERN** - The first one only works in Vibe's internal environment.

### 3. Project Structure from Working App

```
project-root/
â”œâ”€â”€ power.config.json              â† App configuration
â”œâ”€â”€ package.json                   â† Dependencies
â”œâ”€â”€ tsconfig.json                  â† TypeScript config
â”œâ”€â”€ vite.config.ts                 â† Build config
â”œâ”€â”€ index.html                     â† Entry point
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.tsx                   â† React entry (renders App)
â”‚   â”œâ”€â”€ app.tsx                    â† Main app component
â”‚   â”œâ”€â”€ index.css                  â† Global styles (Tailwind)
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ query-client.ts        â† React Query config
â”‚   â”‚   â””â”€â”€ utils.ts               â† Utility functions
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â””â”€â”€ use-mobile.ts          â† Custom hooks
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â””â”€â”€ common-models.ts       â† Shared TypeScript interfaces
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ system/
â”‚   â”‚   â”‚   â””â”€â”€ error-boundary.tsx â† Error handling
â”‚   â”‚   â””â”€â”€ ui/                    â† Shadcn/ui components
â”‚   â”‚       â”œâ”€â”€ alert.tsx
â”‚   â”‚       â”œâ”€â”€ badge.tsx
â”‚   â”‚       â”œâ”€â”€ button.tsx
â”‚   â”‚       â”œâ”€â”€ card.tsx
â”‚   â”‚       â”œâ”€â”€ item.tsx
â”‚   â”‚       â”œâ”€â”€ separator.tsx
â”‚   â”‚       â”œâ”€â”€ spinner.tsx
â”‚   â”‚       â””â”€â”€ sonner.tsx
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ _layout.tsx            â† Layout wrapper
â”‚   â”‚   â”œâ”€â”€ index.tsx              â† Home page
â”‚   â”‚   â””â”€â”€ not-found.tsx          â† 404 page
â”‚   â””â”€â”€ generated/                 â† AUTO-GENERATED by pac command
â”‚       â”œâ”€â”€ hooks/
â”‚       â”‚   â””â”€â”€ useGeorgTown.ts
â”‚       â”œâ”€â”€ models/
â”‚       â”‚   â”œâ”€â”€ common-models.ts
â”‚       â”‚   â””â”€â”€ georg-town-model.ts
â”‚       â”œâ”€â”€ services/
â”‚       â”‚   â””â”€â”€ georg-town-service.ts
â”‚       â””â”€â”€ validators/
â”‚           â””â”€â”€ georg-town-validator.ts
```

---

## ğŸ“‹ COMPLETE FILE CONTENTS

### 1. power.config.json (âœ… Already configured for user)

```json
{
  "appDisplayName": "Project Governance Tool",
  "description": "Governance tool for leaders and teams",
  "environmentId": "deccb389-10c5-4d5c-8716-1093a04538e1",
  "buildPath": "./dist",
  "buildEntryPoint": "index.html",
  "logoPath": "Default",
  "localAppUrl": "http://localhost:5173/",
  "appId": "92b3eb2d-bfcc-49ce-9c50-79b2d456c9af",
  "connectionReferences": {},
  "databaseReferences": {
    "default.cds": {
      "dataSources": {
        "crda8_deliverables": {
          "entitySetName": "crda8_deliverabless",
          "logicalName": "crda8_deliverables",
          "isHidden": false
        },
        "crda8_staff4": {
          "entitySetName": "crda8_staff4s",
          "logicalName": "crda8_staff4",
          "isHidden": false
        },
        "crda8_workstreams": {
          "entitySetName": "crda8_workstreamss",
          "logicalName": "crda8_workstreams",
          "isHidden": false
        }
      }
    }
  }
}
```

### 2. src/main.tsx (Entry Point)

```typescript
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './index.css';
import App from '@/app.tsx';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

### 3. src/app.tsx (Main App)

```typescript
import { useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { QueryClientProvider } from '@tanstack/react-query';
import { Provider as JotaiProvider } from 'jotai';
import { initialize } from '@microsoft/power-apps/app';

import Layout from '@/pages/_layout';
import { queryClient } from '@/lib/query-client';
import { Toaster } from '@/components/ui/sonner';
import ErrorBoundary from '@/components/system/error-boundary';

import HomePage from '@/pages/index';
import NotFoundPage from '@/pages/not-found';

function App() {
  useEffect(() => {
    initialize();
  }, []);

  return (
    <QueryClientProvider client={queryClient}>
      <ErrorBoundary resetQueryCache>
        <JotaiProvider>
          <Toaster />
          <Router>
            <Routes>
              <Route path="/" element={<Layout />}>
                <Route index element={<HomePage />} />
                <Route path="404" element={<NotFoundPage />} />
                <Route path="*" element={<NotFoundPage />} />
              </Route>
            </Routes>
          </Router>
        </JotaiProvider>
      </ErrorBoundary>
    </QueryClientProvider>
  );
}

export default App;
```

**Key Points:**
- `initialize()` from `@microsoft/power-apps/app` - **CRITICAL** call
- `QueryClientProvider` wraps everything
- `ErrorBoundary` with `resetQueryCache` prop
- `JotaiProvider` for state management
- Router with nested routes under Layout

### 4. src/lib/query-client.ts (React Query Config)

```typescript
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,      // 5 minutes
      gcTime: 10 * 60 * 1000,         // 10 minutes
      retry: false,
      refetchOnWindowFocus: false,
      retryOnMount: false,
    },
    mutations: {
      retry: false,
    },
  },
});
```

### 5. src/lib/utils.ts (Utility Functions)

```typescript
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

### 6. src/pages/_layout.tsx (Layout)

```typescript
import { Outlet, Link } from 'react-router';

export default function Layout() {
  return (
    <div className="min-h-dvh bg-background text-foreground">
      <header className="px-6 pt-10">
        <div className="mx-auto max-w-3xl">
          <h1 className="text-4xl font-bold tracking-tight">
            <Link to="/" className="text-primary hover:text-primary/90 transition-colors">
              Project Governance Tool
            </Link>
          </h1>
        </div>
      </header>

      <main className="px-6 pb-10">
        <div className="mx-auto max-w-3xl">
          <Outlet />
        </div>
      </main>
    </div>
  );
}
```

### 7. src/pages/not-found.tsx

```typescript
export default function NotFoundPage() {
  return (
    <div className="min-h-screen bg-background flex items-center justify-center p-4">
      <div className="text-center">
        <h1 className="text-6xl font-bold text-muted-foreground mb-4">404</h1>
        <h2 className="text-2xl font-semibold text-foreground mb-2">Page Not Found</h2>
        <p className="text-muted-foreground mb-8 max-w-md">
          Sorry, the page you are looking for doesn't exist or has been moved.
        </p>
        <a
          href="/"
          className="inline-flex items-center px-4 py-2 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 transition-colors"
        >
          Go Back Home
        </a>
      </div>
    </div>
  );
}
```

---

## ğŸ”§ AUTO-GENERATED FILES PATTERN

### Generated Service Pattern

**File: `src/generated/services/georg-town-service.ts`**

```typescript
import type { GeorgTown } from '../models/georg-town-model';
import type { IGetAllOptions } from '../models/common-models';
import type { IOperationResult } from '@microsoft/power-apps/data';
import { getClient } from '@microsoft/power-apps-data';  // â† Regular Code Apps path

export class GeorgTownService {
  private static readonly dataSourceName = 'GeorgTown';
  private static readonly client = getClient();

  public static async create(record: Omit<GeorgTown, 'id'>): Promise<IOperationResult<GeorgTown>> {
    const result = await GeorgTownService.client.createRecordAsync<Omit<GeorgTown, 'id'>, GeorgTown>(
      GeorgTownService.dataSourceName,
      record
    );
    return result;
  }

  public static async update(id: string, changedFields: Partial<Omit<GeorgTown, 'id'>>): Promise<IOperationResult<GeorgTown>> {
    const result = await GeorgTownService.client.updateRecordAsync<Partial<Omit<GeorgTown, 'id'>>, GeorgTown>(
      GeorgTownService.dataSourceName,
      id.toString(),
      changedFields
    );
    return result;
  }

  public static async delete(id: string): Promise<void> {
    await GeorgTownService.client.deleteRecordAsync(
      GeorgTownService.dataSourceName,
      id.toString()
    );
  }

  public static async get(id: string): Promise<IOperationResult<GeorgTown>> {
    const result = await GeorgTownService.client.retrieveRecordAsync<GeorgTown>(
      GeorgTownService.dataSourceName,
      id.toString()
    );
    return result;
  }

  public static async getAll(options?: IGetAllOptions): Promise<IOperationResult<GeorgTown[]>> {
    const result = await GeorgTownService.client.retrieveMultipleRecordsAsync<GeorgTown>(
      GeorgTownService.dataSourceName,
      options
    );
    return result;
  }
}
```

### Generated Model Pattern

**File: `src/generated/models/georg-town-model.ts`**

```typescript
export interface GeorgTown {
  /**
   * @displayName GeorgTown
   * @typeHint uuid
   * @validationRule Required for create/update operations
   */
  id: string;

  /**
   * @displayName Town Name
   * @format Text
   * @maxLength 850
   * @validationRule Required for create/update operations
   */
  townName: string;

  /**
   * @displayName Country
   * @format Text
   * @maxLength 100
   */
  country?: string;

  /**
   * @displayName Population
   * @typeHint int
   * @minValue -2147483648
   * @maxValue 2147483647
   */
  population?: number;

  /**
   * @displayName State
   * @format Text
   * @maxLength 100
   */
  state?: string;
}
```

### Generated Validator Pattern

**File: `src/generated/validators/georg-town-validator.ts`**

```typescript
import { z } from 'zod';

export const GeorgTownSchema = z.object({
  id: z.string().uuid(),
  townName: z.string().max(850).min(1, "Town Name is required"),
  country: z.string().max(100).optional(),
  population: z.number().int().min(-2147483648).max(2147483647).optional(),
  state: z.string().max(100).optional(),
});

export const CreateGeorgTownSchema = GeorgTownSchema.omit({ id: true });
export const UpdateGeorgTownSchema = GeorgTownSchema;

export type GeorgTownInput = z.infer<typeof GeorgTownSchema>;
export type CreateGeorgTownInput = z.infer<typeof CreateGeorgTownSchema>;
export type UpdateGeorgTownInput = z.infer<typeof UpdateGeorgTownSchema>;
```

### Generated Common Models

**File: `src/generated/models/common-models.ts`**

```typescript
export interface IGetAllOptions {
  // Filter format: "propertyName eq 'value'" or "propertyName gt 100"
  // For dates: use ge/lt instead of eq
  // For lookups: "lookupProperty/id eq 'guid'" or "lookupProperty/displayName eq 'value'"
  filter?: string;

  // OrderBy format: ["propertyName asc", "otherProperty desc"]
  orderBy?: string[];
}
```

### Generated Hook Pattern (React Query)

**File: `src/generated/hooks/useGeorgTown.ts`**

```typescript
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { GeorgTownService } from "../services/georg-town-service";
import type { GeorgTown } from "../models/georg-town-model";
import type { IGetAllOptions } from "../models/common-models";

export function useGeorgTownList(options?: IGetAllOptions) {
  return useQuery({
    queryKey: ["georgtown-list", options],
    queryFn: async () => {
      const result = await GeorgTownService.getAll(options);
      if (!result.success) {
        throw result.error;
      }
      return result.data;
    },
  });
}

export function useGeorgTown(id: string) {
  return useQuery({
    queryKey: ["georgtown", id],
    queryFn: async () => {
      const result = await GeorgTownService.get(id);
      if (!result.success) {
        throw result.error;
      }
      return result.data;
    },
    enabled: !!id,
  });
}

export function useCreateGeorgTown() {
  const client = useQueryClient();
  return useMutation({
    mutationFn: async (data: Omit<GeorgTown, "id">) => {
      const result = await GeorgTownService.create(data);
      if (!result.success) {
        throw result.error;
      }
      return result.data;
    },
    onSuccess: () => {
      client.invalidateQueries({ queryKey: ["georgtown-list"] });
    },
  });
}

export function useUpdateGeorgTown() {
  const client = useQueryClient();
  return useMutation({
    mutationFn: async ({
      id,
      changedFields,
    }: {
      id: string;
      changedFields: Partial<Omit<GeorgTown, "id">>;
    }) => {
      const result = await GeorgTownService.update(id, changedFields);
      if (!result.success) {
        throw result.error;
      }
      return result.data;
    },
    onSuccess: (_data, variables) => {
      client.invalidateQueries({ queryKey: ["georgtown-list"] });
      client.invalidateQueries({ queryKey: ["georgtown", variables.id] });
    },
  });
}

export function useDeleteGeorgTown() {
  const client = useQueryClient();
  return useMutation({
    mutationFn: async (id: string) => {
      await GeorgTownService.delete(id);
    },
    onSuccess: (_data, id) => {
      client.invalidateQueries({ queryKey: ["georgtown-list"] });
      client.invalidateQueries({ queryKey: ["georgtown", id] });
    },
  });
}
```

---

## ğŸ“¦ REQUIRED DEPENDENCIES

**package.json dependencies:**

```json
{
  "dependencies": {
    "@microsoft/power-apps": "^1.0.0",
    "@microsoft/power-apps-data": "^1.0.0",
    "@tanstack/react-query": "^5.0.0",
    "jotai": "^2.0.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.0.0",
    "zod": "^3.22.0",
    "clsx": "^2.0.0",
    "tailwind-merge": "^2.0.0"
  },
  "devDependencies": {
    "@types/react": "^18.3.1",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.0.0",
    "typescript": "^5.3.0",
    "vite": "^5.0.0",
    "tailwindcss": "^3.4.0",
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0"
  }
}
```

---

## ğŸ¯ USAGE EXAMPLE (Staff List)

**File: `src/pages/staff.tsx`**

```typescript
import { useStaffList, useCreateStaff, useUpdateStaff, useDeleteStaff } from "@/generated/hooks/useStaff";

export default function StaffPage() {
  // Fetch staff with filter and sort
  const { data: staff, isLoading, isError, error, refetch } = useStaffList({
    filter: "crda8_active eq true",
    orderBy: ["crda8_name asc"]
  });

  const createMutation = useCreateStaff();
  const updateMutation = useUpdateStaff();
  const deleteMutation = useDeleteStaff();

  if (isLoading) return <div>Loading staff...</div>;
  if (isError) return <div>Error: {error.message}</div>;

  const handleCreate = () => {
    createMutation.mutate({
      crda8_name: "John Doe",
      crda8_email: "john@example.com",
      crda8_role: "Developer"
    });
  };

  const handleUpdate = (id: string) => {
    updateMutation.mutate({
      id,
      changedFields: { crda8_role: "Senior Developer" }
    });
  };

  const handleDelete = (id: string) => {
    deleteMutation.mutate(id);
  };

  return (
    <div>
      <h2>Staff List ({staff?.length ?? 0})</h2>
      {staff?.map(person => (
        <div key={person.id}>
          <h3>{person.crda8_name}</h3>
          <p>{person.crda8_email}</p>
          <button onClick={() => handleUpdate(person.id)}>Promote</button>
          <button onClick={() => handleDelete(person.id)}>Remove</button>
        </div>
      ))}
      <button onClick={handleCreate}>Add Staff</button>
    </div>
  );
}
```

---

## âš ï¸ CRITICAL MISTAKES TO AVOID

### âŒ DON'T: Manually create services
```typescript
// WRONG - Don't create this manually
export const dataverseService = {
  async getStaff() {
    const response = await fetch('/api/data/v9.0/crda8_staff4s');
    return response.json();
  }
};
```

### âœ… DO: Use pac command
```bash
pac code add-data-source -a dataverse -t crda8_staff4
```

### âŒ DON'T: Use SharePoint Graph API
```typescript
// WRONG - This is SharePoint, not Dataverse!
const GRAPH_API = 'https://graph.microsoft.com/v1.0';
```

### âœ… DO: Use generated service
```typescript
import { StaffService } from '@/generated/services/staff-service';
const result = await StaffService.getAll();
```

### âŒ DON'T: Guess entity set names
```typescript
// WRONG - Guessing plural form
fetch('/api/data/v9.0/crda8_staff4s');  // might be wrong!
```

### âœ… DO: Let pac command handle it
The command reads your table schema and generates correct names.

---

## ğŸš€ STEP-BY-STEP FOR CODEX

### Phase 1: Remove ALL SharePoint Code

1. **Delete** `src/services/sharepointService.ts`
2. **Delete** any SharePoint-related imports
3. **Delete** any Graph API code
4. **Remove** fake/local data arrays

### Phase 2: Structure Setup

1. **Keep** existing:
   - `power.config.json` (already correct)
   - `package.json` (but update dependencies)

2. **Create** if missing:
   - `src/lib/query-client.ts`
   - `src/lib/utils.ts`
   - `src/pages/_layout.tsx`
   - `src/pages/not-found.tsx`
   - `src/models/common-models.ts` (or wait for pac to generate)

3. **Update** `src/app.tsx`:
   - Add `initialize()` from `@microsoft/power-apps/app`
   - Wrap in `QueryClientProvider`
   - Add `ErrorBoundary`

### Phase 3: Generate Dataverse Code

Run these commands **one at a time**:

```bash
pac code add-data-source -a dataverse -t crda8_deliverables
pac code add-data-source -a dataverse -t crda8_staff4
pac code add-data-source -a dataverse -t crda8_workstreams
```

Each command will create 4 files in `src/generated/`.

### Phase 4: Update Pages to Use Generated Hooks

**Example for Staff page:**

```typescript
// OLD (SharePoint - DELETE THIS)
import { getStaffFromSharePoint } from '../services/sharepointService';

// NEW (Dataverse - USE THIS)
import { useStaffList } from '@/generated/hooks/useStaff';

export default function StaffPage() {
  const { data: staff, isLoading } = useStaffList({
    orderBy: ["crda8_name asc"]
  });

  // ... rest of component
}
```

### Phase 5: Test and Deploy

```bash
# Test locally
pac code run

# Build
npm run build

# Deploy
pac code push
```

---

## ğŸ“ FINAL CHECKLIST FOR CODEX

- [ ] Removed ALL SharePoint service code
- [ ] Removed ALL fake/local data
- [ ] Updated `app.tsx` with `initialize()` and providers
- [ ] Created `query-client.ts` with proper config
- [ ] Ran `pac code add-data-source` for each table
- [ ] Verified `src/generated/` folder has hooks, models, services, validators
- [ ] Updated all page components to use generated hooks
- [ ] NO manual `fetch()` calls anywhere
- [ ] NO hardcoded data arrays
- [ ] Using `@microsoft/power-apps-data` (NOT `@microsoft/power-apps/data` from Vibe)
- [ ] All imports use `@/` path alias
- [ ] Error handling with ErrorBoundary
- [ ] Loading states with `isLoading`
- [ ] Mutations invalidate queries on success

---

## ğŸ“ KEY CONCEPTS FOR CODEX

### The Data Flow

```
User Action (UI)
    â†“
React Query Hook (useStaffList)
    â†“
Service Layer (StaffService.getAll)
    â†“
Power Apps Data Client (getClient())
    â†“
Dataverse Web API
    â†“
Returns IOperationResult<Staff[]>
    â†“
React Query caches and returns data
    â†“
UI displays data
```

### The IOperationResult Pattern

All Dataverse operations return this structure:

```typescript
interface IOperationResult<T> {
  success: boolean;
  data?: T;
  error?: Error;
}
```

Always check `result.success` before using `result.data`.

### The Query Invalidation Pattern

When you create/update/delete, you must invalidate queries:

```typescript
onSuccess: () => {
  client.invalidateQueries({ queryKey: ["staff-list"] });
}
```

This triggers a refetch so the UI updates with fresh data.

---

## âœ… YOU ARE NOW READY

This document contains **everything you need** to build a working Dataverse-connected Power Apps Code App.

Follow this pattern **exactly** and you will succeed.

**DO NOT DEVIATE** from this pattern unless you have a very good reason.

Good luck! ğŸš€
